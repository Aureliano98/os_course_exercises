# lec10: lab3 SPOC思考题

## 视频相关思考题
---
### 10.1 实验目标：虚存管理
---

1. 缺页和页访问非法的返回地址有什么不同？

	如果“返回地址”是指引发指令异常的（线性）地址，那么都是那条指令的地址；

	可能实际上是说造成异常虚拟地址？那么前者是合法但非驻留的，后者可能是非法的，也可能是访问权限引发异常。

2. 虚拟内存管理中是否用到了段机制？

	没有**直接**用到（学堂在线10.1），但开启页机制需要开启段机制。

3. ucore如何知道页访问异常的地址？

	硬件将引发页访问异常的线性地址存储在cr2寄存器中。

### 10.2 回顾历史和了解当下
---

1. 中断处理例程的段表在GDT还是LDT？

	GDT

2. 物理内存管理的数据结构在哪？

	kern/mm/memlayout.h::Page

3. 页表项的结构？
	
	![](Page_dir.png)
	
	PDE的高20位存储页表物理地址的高20位(4KB对齐)，第11-9位交给OS自由使用，低9位为标志位。具体含义如下（若不加说明为正逻辑）
	
	* S, Page Size: 1指定页大小为4MB，否则为4KB（对ucore无用）
	* A, Accessed: 修改位，该页是否被修改，需要OS清零
	* D, Cache Disable: 若为1，该页不会被cache
	* W, Write-Through: 若为1，使用write-through（写直达）, 否则write-back（写回）
	* U, User/Supervisor: 若为1，该页可被所有用户使用；否则，只有内核可使用。
	* R, Read/Write permission: 若为1，可读可写；否则，只读
	* P, Present: 存在位
	
	![](Page_table.png)
	
	PTE的高20位存储页帧物理地址的高20位(4KB对齐)，第11-9位交给OS自由使用，低9位为标志位。大多数意义与PDE相同，除了：
	
	* C, Cached: 与PDE的D位相同
	* G, Global: 若为1，防止TLB在CR3被重新赋值时将该物理地址替换掉
	* D, Dirty: 该页是否被写过，需要OS设置、清零
	* 0: 一定情况下与内存类型有关，否则必须为0

4. 页表项的修改代码？

	缺页异常处理代码，调用链是`trap > trap_dispatch > pgfault_handler > do_pgfault`
 
5. 如何设置一个虚拟地址到物理地址的映射关系？

	设置PTE, PDE.
 
6. 为了建立虚拟内存管理，需要在哪个数据结构中表示“合法”虚拟内存

	PTE中的有效位(P)
 
### 10.3 处理流程、关键数据结构和功能
---

1. swap_init()做了些什么？

	初始化对换分区。

2. vmm_init()做了些什么？

	初始化逻辑地址空间。实际上Lab3并没有显式地做什么初始化，只检查了`vma_struct`, `mm_struct`和相关函数，以及page fault是否能正确处理。

3. vma_struct数据结构的功能？

	描述一段合法的逻辑地址空间。

4. mmap_list是什么列表？

	`mmap_list`是`mm_struct`的成员，形成一个`vma_struct`的链表，描述了整个进程的合法地址空间。

5. 外存中的页面后备如何找到？

	存在但不在内存中的页面对应的页表项的地址中填写的是磁盘扇区，`swapfs_read`会将页面读入。

6. vma\_struct和mm\_struct的关系是什么？

	* `vma_struct`: 描述一段连续的虚拟内存空间
	* `mm_struct`: 描述一个进程所有合法的虚拟地址空间

7. 画数据结构图，描述进程的虚拟地址空间、页表项、物理页面和后备页面的关系；

	见`lec10-2018-chy.ppt`第23页，除了左边`mm_struct`和`vma_struct`的关系有些凌乱之外其他都很清楚。

### 10.4 页访问异常
---

1. 页面不在内存和页面访问非法的处理中有什么区别？对应的代码区别在哪？

	前者是page fault，后者是general protection fault. 前者最终`trap_dispatch`会转交给`do_pgfault`，后者直接就panic了。

1. find_vma()做了些什么？

	找一个`mm_struct`中包含给定地址的`vma_struct`
 
1. swapfs_read()做了些什么？

	调用`ide_read_secs`，将页面从硬盘中读取到由`Page`结构指定内存位置（不是`Page`结构本身）。
 
1. 缺页时的页面创建代码在哪？

	`do_pgfault`
 
1. struct rb_tree数据结构的原理是什么？在虚拟管理中如何用它的？

	ucore中没有。Linux中有`rbtree`结构，内核中很多模块都使用了该结构。需要用与ucore中类似的指针强转操作实现泛型，并且需要补充查找、插入、删除代码。
 
1. 页目录项和页表项的dirty bit是何时，由谁置1的？

	硬件
 
1. 页目录项和页表项的access bit是何时，由谁置1的？
	
	硬件

### 10.5 页换入换出机制
---

1. 虚拟页与磁盘后备页面的对应有关系？

	PTE中如果驻留位为0，则正常应该存储物理地址高20位的地方存储磁盘扇区，`swapfs_read`可以将其读入内存。
 
1. 如果在开始加载可执行文件时，如何改？

	没看懂
 
1. check\_swap()做了些什么检查？
	
	* 检查`free_list`以及`mm_struct`和`vma_struct`结构是否正确（地址转换）
	* 检查访问指定地址后是否正确引发 / 不引发page fault（页面换入换出）
	
1. swap\_entry\_t数据结构做什么用的？放在什么地方？
 	
	`swap_entry_t`只是一个指针的alias, 放在合法但不驻留的PTE中，表示磁盘交换分区的扇区。

1. 空闲物理页面的组织数据结构是什么？

	`free_area_t`，包含`Page`的链表和一个链表大小的计数器。
 
1. 置换算法的接口数据结构？

	`kern/mm/swap.h::swap_manager`

================


## 小组思考题
---
(1)请参考lab3_result的代码，思考如何在lab3_results中实现clock算法，给出你的概要设计方案。可4人一个小组。要求说明你的方案中clock算法与LRU算法上相比，潜在的性能差异性。进而说明在lab3的LRU算法实现的可能性评价（给出理由）。

(2) 理解内存访问的异常。在x86中内存访问会受到段机制和页机制的两层保护，请基于lab3_results的代码（包括lab1的challenge练习实现），请实践并分析出段机制和页机制各种内存非法访问的后果。，可4人一个小组，，找出尽可能多的各种内存访问异常，并在代码中给出实现和测试用例，在执行了测试用例后，ucore能够显示出是出现了哪种异常和尽量详细的错误信息。请在说明文档中指出：某种内存访问异常的原因，硬件的处理过程，以及OS如何处理，是否可以利用做其他有用的事情（比如提供比物理空间更大的虚拟空间）？哪些段异常是否可取消，并用页异常取代？

## 课堂实践练习

请分析ucore中与物理内存管理和虚拟存储管理相关的数据结构组织；分析访问这些数据结构的函数，说明其对存储管理相关数据结构的修改情况；最后通过一个数据结构图示，描述进程的虚拟地址空间、页表项、物理页面和后备页面的关系。

 * struct Page
 * struct mm_struct
 * struct vma_struct
 * struct swap_entry

## v9-cpu相关
---
(1)分析并编译运行v9-cpu git repo的testing branch中的,root/etc/os_lab2.c os_lab3.c os_lab3_1.c,理解虚存机制是如何在v9-cpu上实现的，思考如何实现clock页替换算法，并给出你的概要设计方案。

(2)分析并编译运行v9-cpu git repo的testing branch中的,root/etc/os_lab2.c os_lab3.c os_lab3_1.c，理解内存访问异常的各种情况，并给出你的分析结果。
